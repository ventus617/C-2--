#include <stdio.h>
/*
约瑟夫环问题
遇到环问题 使用求余算法在达成循环赋值

据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，
39 个犹太人与Josephus及他的朋友躲到一个洞中，
39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，
41个人排成一个圆圈，由第1个人开始报数，
每报数到第3人该人就必须自杀，
然后再由下一个重新报数，直到所有人都自杀身亡为止。
然而Josephus 和他的朋友并不想遵从。
首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。
接着，再越过k-1个人，并杀掉第k个人。
这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。
问题是，给定了和，一开始要站在什么地方才能避免被处决。
Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。
*/
int main19()
{
	int r[41] ;
	int m=3;//数到几
	int n=41;//当前活着的人数
	int i=0,j=0,k;
	for( k=0;k<41 ;k++ )
	{
		r[k]=k+1;
	}
	while (n >= 1)//这里等于1是要把所有数输出，不等于1则完全满足题目条件
	{
		//找到 死掉的人
		i = (i + m - 1) % n;//i+m-1 是因为叫的号是包含自己的
		//并且在重新排号后，由于往前赋值，本来该叫的下一个人会站在死掉的人位置上 因此会得出-1
		//利用 求余的循环赋值特性 找到在整个队伍满足该关系的人
		printf("%d ",r[i]);
		//后面的数 向前 覆盖死掉的人
		for (k = i + 1; k < n; k++)
		{
			r[k - 1] = r[k];
		}
		n--;//人数减小
	}
	 
	return 0;
}